---
description: "Standards compliance confirmed"
globs: []
alwaysApply: false
---

## Overview
This kit provides everything needed to simulate a full development team using AI personas, enabling solo developers to handle enterprise-scale projects that would normally require 5+ team members.

## Quick Start Implementation

### Step 1: Team Composition Setup
```bash
# Create team configuration
cat > team_config.json << 'EOF'
{
  "team_structure": {
    "strategic_layer": {
      "product_owner_ai": {
        "role": "Business Strategy & Requirements",
        "specialization": "user_stories, prioritization, stakeholder_management",
        "context_focus": ["business_requirements", "market_analysis", "user_feedback"]
      },
      "planning_ai": {
        "role": "Project Roadmap & Technical Planning",
        "specialization": "roadmap_creation, sprint_planning, risk_assessment",
        "context_focus": ["technical_requirements", "timeline_planning", "resource_allocation"]
      }
    },
    "technical_leadership": {
      "principal_engineer_ai": {
        "role": "Architecture & Technical Leadership",
        "specialization": "system_design, technology_evaluation, code_reviews",
        "context_focus": ["architectural_patterns", "technology_stack", "design_principles"]
      },
      "security_ai": {
        "role": "Security & Compliance",
        "specialization": "security_audit, compliance_review, threat_modeling",
        "context_focus": ["security_requirements", "compliance_standards", "vulnerability_assessment"]
      }
    },
    "development_team": {
      "codegen_ai": {
        "role": "Primary Development & Implementation",
        "specialization": "feature_development, bug_fixes, code_optimization",
        "context_focus": ["implementation_details", "coding_standards", "performance_requirements"]
      },
      "qa_ai": {
        "role": "Quality Assurance & Testing",
        "specialization": "test_creation, quality_validation, automation_testing",
        "context_focus": ["test_scenarios", "quality_criteria", "bug_tracking"]
      }
    },
    "support_specialists": {
      "auditor_ai": {
        "role": "Code Quality & Standards Compliance",
        "specialization": "code_auditing, standards_enforcement, quality_reporting",
        "context_focus": ["coding_standards", "quality_metrics", "compliance_requirements"]
      },
      "documentation_ai": {
        "role": "Technical Documentation & Knowledge Base",
        "specialization": "documentation_creation, api_documentation, knowledge_management",
        "context_focus": ["technical_writing", "api_documentation", "knowledge_organization"]
      }
    }
  },
  "team_coordination": {
    "communication_protocol": "structured_handoffs",
    "context_sharing": "intelligent_memory_bridge",
    "decision_making": "collaborative_validation",
    "quality_gates": "multi_layer_approval"
  }
}
EOF
```

### Step 2: Context Management Setup
```bash
# Initialize context management system
cat > context_config.yaml << 'EOF'
context_management:
  memory_layers:
    project_memory:
      - requirements_evolution
      - architectural_decisions
      - code_patterns
      - stakeholder_feedback

    session_memory:
      - active_tasks
      - recent_changes
      - pending_reviews
      - conversation_history

    team_memory:
      - handoffs
      - decisions
      - learnings
      - performance_metrics

  optimization_strategies:
    compression_enabled: true
    prioritization_enabled: true
    chunking_enabled: true
    validation_enabled: true

  performance_targets:
    context_retention: "12x_baseline"
    relevance_accuracy: "90%+"
    retrieval_speed: "<100ms"
    memory_efficiency: "70%+"
EOF
```

### Step 3: Workflow Orchestration Setup
```bash
# Create workflow orchestration script
cat > orchestrate_team.py << 'EOF'
#!/usr/bin/env python3
import json
import sys
import os
from pathlib import Path
from datetime import datetime

class AITeamOrchestrator:
    def __init__(self, team_config_path="team_config.json"):
        self.team_config = self.load_team_config(team_config_path)
        self.context_manager = ContextManager()
        self.decision_scorer = DecisionScorer()
        self.quality_gate = QualityGate()

    def load_team_config(self, path):
        with open(path, 'r') as f:
            return json.load(f)

    def simulate_sprint_workflow(self, sprint_requirements):
        """Simulate complete sprint workflow with all team members"""

        print("üöÄ Starting AI Team Sprint Simulation")
        print("=" * 50)

        # Phase 1: Sprint Planning
        print("\nüìã Phase 1: Sprint Planning")
        planning_results = self.execute_planning_phase(sprint_requirements)

        # Phase 2: Development
        print("\nüíª Phase 2: Development")
        development_results = self.execute_development_phase(planning_results)

        # Phase 3: Quality Assurance
        print("\nüß™ Phase 3: Quality Assurance")
        qa_results = self.execute_qa_phase(development_results)

        # Phase 4: Review & Deployment
        print("\nüîç Phase 4: Review & Deployment")
        deployment_results = self.execute_deployment_phase(qa_results)

        print("\n‚úÖ Sprint Complete!")
        return deployment_results

    def execute_planning_phase(self, requirements):
        """Product Owner + Planning AI collaboration"""
        print("  ü§ù Product Owner AI: Analyzing requirements...")
        print("  üìä Planning AI: Creating technical breakdown...")

        # Simulate AI interactions
        user_stories = self.generate_user_stories(requirements)
        technical_tasks = self.break_down_tasks(user_stories)
        sprint_plan = self.create_sprint_plan(technical_tasks)

        return {
            'user_stories': user_stories,
            'technical_tasks': technical_tasks,
            'sprint_plan': sprint_plan
        }

    def execute_development_phase(self, planning_results):
        """Codegen AI + Principal Engineer collaboration"""
        print("  üîß Principal Engineer AI: Reviewing architecture...")
        print("  üíª Codegen AI: Implementing features...")

        implemented_features = []
        for task in planning_results['technical_tasks']:
            # Architecture review
            architecture_review = self.review_architecture(task)

            # Code implementation
            implementation = self.implement_feature(task, architecture_review)

            # Code review simulation
            review_results = self.simulate_code_review(implementation)

            implemented_features.append({
                'task': task,
                'implementation': implementation,
                'review': review_results
            })

        return implemented_features

    def execute_qa_phase(self, development_results):
        """QA AI + Security AI collaboration"""
        print("  üß™ QA AI: Creating test suites...")
        print("  üîí Security AI: Performing security review...")

        qa_results = []
        for feature in development_results:
            # Test creation and execution
            tests = self.create_comprehensive_tests(feature)

            # Security assessment
            security_review = self.perform_security_review(feature)

            # Quality validation
            quality_score = self.validate_quality(feature, tests, security_review)

            qa_results.append({
                'feature': feature,
                'tests': tests,
                'security_review': security_review,
                'quality_score': quality_score
            })

        return qa_results

    def execute_deployment_phase(self, qa_results):
        """Auditor AI + Documentation AI collaboration"""
        print("  üìã Auditor AI: Final quality audit...")
        print("  üìö Documentation AI: Creating documentation...")

        deployment_ready = []
        for qa_result in qa_results:
            # Final audit
            audit_results = self.perform_final_audit(qa_result)

            # Documentation creation
            documentation = self.generate_documentation(qa_result)

            # Deployment validation
            deployment_check = self.validate_deployment_readiness(qa_result, audit_results)

            deployment_ready.append({
                'feature': qa_result['feature'],
                'audit': audit_results,
                'documentation': documentation,
                'deployment_ready': deployment_check
            })

        return deployment_ready

    # Helper methods (implement based on your specific AI integration)
    def generate_user_stories(self, requirements): return ["User story 1", "User story 2"]
    def break_down_tasks(self, stories): return ["Task 1", "Task 2"]
    def create_sprint_plan(self, tasks): return {"plan": "Sprint plan created"}
    def review_architecture(self, task): return {"review": "Architecture approved"}
    def implement_feature(self, task, review): return {"code": "Feature implemented"}
    def simulate_code_review(self, implementation): return {"review": "Code review passed"}
    def create_comprehensive_tests(self, feature): return {"tests": "Test suite created"}
    def perform_security_review(self, feature): return {"security": "Security review passed"}
    def validate_quality(self, feature, tests, security): return 95
    def perform_final_audit(self, qa_result): return {"audit": "Final audit passed"}
    def generate_documentation(self, qa_result): return {"docs": "Documentation created"}
    def validate_deployment_readiness(self, qa_result, audit): return True

def main():
    if len(sys.argv) < 2:
        print("Usage: python orchestrate_team.py <sprint_requirements.json>")
        sys.exit(1)

    requirements_file = sys.argv[1]

    # Load sprint requirements
    with open(requirements_file, 'r') as f:
        sprint_requirements = json.load(f)

    # Initialize orchestrator
    orchestrator = AITeamOrchestrator()

    # Execute sprint simulation
    results = orchestrator.simulate_sprint_workflow(sprint_requirements)

    # Save results
    output_file = f"sprint_results_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
    with open(output_file, 'w') as f:
        json.dump(results, f, indent=2)

    print(f"\nüìÑ Results saved to: {output_file}")

if __name__ == "__main__":
    main()
EOF

chmod +x orchestrate_team.py
```

### Step 4: Quality Gates Setup
```bash
# Create quality gates configuration
cat > quality_gates_config.yaml << 'EOF'
quality_gates:
  pre_commit:
    name: "Pre-commit Quality Gate"
    checks:
      - linting_passed:
          description: "All linting rules satisfied"
          severity: "blocker"
      - tests_passing:
          description: "Unit tests successful"
          severity: "blocker"
      - security_scan_clean:
          description: "No critical vulnerabilities"
          severity: "blocker"

  pre_merge:
    name: "Pre-merge Quality Gate"
    checks:
      - integration_tests_passed:
          description: "All integration tests successful"
          severity: "blocker"
      - code_coverage_above_threshold:
          description: "Minimum 80% coverage"
          severity: "major"
      - security_review_completed:
          description: "Security assessment finished"
          severity: "blocker"

  pre_deploy:
    name: "Pre-deployment Quality Gate"
    checks:
      - performance_tests_passed:
          description: "Performance benchmarks met"
          severity: "blocker"
      - documentation_updated:
          description: "All docs current"
          severity: "major"
      - audit_compliance_verified:
          description: "Standards compliance confirmed"
          severity: "blocker"

gate_triggers:
  automatic:
    - on_pull_request
    - on_push_to_main
    - scheduled_daily

  manual:
    - on_demand_quality_check
    - pre_release_validation
    - emergency_deployment_check
EOF
```

### Step 5: Performance Monitoring Setup
```bash
# Create performance monitoring dashboard
cat > performance_monitor.py << 'EOF'
#!/usr/bin/env python3
import json
import time
from collections import defaultdict
from datetime import datetime, timedelta

class AITeamPerformanceMonitor:
    def __init__(self):
        self.metrics = defaultdict(list)
        self.start_time = datetime.now()

    def track_metric(self, category, metric_name, value, metadata=None):
        """Track a performance metric"""
        timestamp = datetime.now()
        metric_data = {
            'timestamp': timestamp.isoformat(),
            'category': category,
            'metric_name': metric_name,
            'value': value,
            'metadata': metadata or {}
        }

        self.metrics[category].append(metric_data)
        print(f"üìä [{timestamp.strftime('%H:%M:%S')}] {category}.{metric_name}: {value}")

    def track_ai_interaction(self, persona, action, duration, success=True):
        """Track AI persona interactions"""
        self.track_metric('ai_interaction', f"{persona}_{action}", {
            'duration_seconds': duration,
            'success': success,
            'persona': persona,
            'action': action
        })

    def track_quality_metric(self, gate_name, check_name, passed, details=None):
        """Track quality gate results"""
        self.track_metric('quality_gate', f"{gate_name}_{check_name}", {
            'passed': passed,
            'gate': gate_name,
            'check': check_name,
            'details': details or {}
        })

    def track_context_operation(self, operation, size_before, size_after, duration):
        """Track context management operations"""
        compression_ratio = size_after / size_before if size_before > 0 else 0
        self.track_metric('context_management', operation, {
            'size_before': size_before,
            'size_after': size_after,
            'compression_ratio': compression_ratio,
            'duration_seconds': duration
        })

    def generate_performance_report(self):
        """Generate comprehensive performance report"""
        report = {
            'report_generated': datetime.now().isoformat(),
            'monitoring_duration': str(datetime.now() - self.start_time),
            'summary': self.generate_summary(),
            'detailed_metrics': dict(self.metrics),
            'recommendations': self.generate_recommendations()
        }

        return report

    def generate_summary(self):
        """Generate performance summary"""
        summary = {}

        # AI Interaction Summary
        ai_interactions = self.metrics.get('ai_interaction', [])
        if ai_interactions:
            total_interactions = len(ai_interactions)
            successful_interactions = len([i for i in ai_interactions if i['value']['success']])
            avg_duration = sum(i['value']['duration_seconds'] for i in ai_interactions) / total_interactions

            summary['ai_interactions'] = {
                'total': total_interactions,
                'successful': successful_interactions,
                'success_rate': successful_interactions / total_interactions * 100,
                'average_duration_seconds': avg_duration
            }

        # Quality Gate Summary
        quality_checks = self.metrics.get('quality_gate', [])
        if quality_checks:
            total_checks = len(quality_checks)
            passed_checks = len([c for c in quality_checks if c['value']['passed']])

            summary['quality_gates'] = {
                'total_checks': total_checks,
                'passed_checks': passed_checks,
                'pass_rate': passed_checks / total_checks * 100
            }

        # Context Management Summary
        context_ops = self.metrics.get('context_management', [])
        if context_ops:
            total_ops = len(context_ops)
            avg_compression = sum(op['value']['compression_ratio'] for op in context_ops) / total_ops

            summary['context_management'] = {
                'total_operations': total_ops,
                'average_compression_ratio': avg_compression
            }

        return summary

    def generate_recommendations(self):
        """Generate performance recommendations"""
        recommendations = []

        summary = self.generate_summary()

        # AI Performance Recommendations
        if 'ai_interactions' in summary:
            ai_stats = summary['ai_interactions']
            if ai_stats['success_rate'] < 95:
                recommendations.append({
                    'type': 'ai_performance',
                    'priority': 'high',
                    'description': f"AI success rate is {ai_stats['success_rate']:.1f}%. Consider prompt optimization.",
                    'action': 'Review and optimize AI prompts for better success rates'
                })

            if ai_stats['average_duration_seconds'] > 30:
                recommendations.append({
                    'type': 'ai_performance',
                    'priority': 'medium',
                    'description': f"Average AI response time is {ai_stats['average_duration_seconds']:.1f}s. Consider optimization.",
                    'action': 'Optimize context size and prompt length for faster responses'
                })

        # Quality Recommendations
        if 'quality_gates' in summary:
            quality_stats = summary['quality_gates']
            if quality_stats['pass_rate'] < 90:
                recommendations.append({
                    'type': 'quality_improvement',
                    'priority': 'high',
                    'description': f"Quality gate pass rate is {quality_stats['pass_rate']:.1f}%. Review failing checks.",
                    'action': 'Investigate and fix recurring quality gate failures'
                })

        # Context Management Recommendations
        if 'context_management' in summary:
            context_stats = summary['context_management']
            if context_stats['average_compression_ratio'] > 0.8:
                recommendations.append({
                    'type': 'context_optimization',
                    'priority': 'low',
                    'description': f"Context compression ratio is {context_stats['average_compression_ratio']:.2f}. Good efficiency.",
                    'action': 'Monitor context compression - current levels are optimal'
                })

        return recommendations

# Example usage
if __name__ == "__main__":
    monitor = AITeamPerformanceMonitor()

    # Simulate some metrics
    monitor.track_ai_interaction('codegen_ai', 'implement_feature', 15.2, True)
    monitor.track_ai_interaction('qa_ai', 'create_tests', 8.7, True)
    monitor.track_quality_metric('pre_commit', 'linting', True)
    monitor.track_context_operation('compress', 10000, 3000, 0.5)

    # Generate report
    report = monitor.generate_performance_report()

    # Save report
    with open('performance_report.json', 'w') as f:
        json.dump(report, f, indent=2)

    print("\nüìà Performance Report Generated!")
    print("üí° Recommendations:")
    for rec in report['recommendations']:
        print(f"  ‚Ä¢ {rec['description']}")
EOF

chmod +x performance_monitor.py
```

## Advanced Implementation Strategies

### Strategy 1: Context-Aware Task Assignment
```python
class IntelligentTaskAssigner:
    def assign_optimal_persona(self, task_description, context):
        """Assign tasks to most suitable AI personas based on context"""

        # Analyze task requirements
        task_analysis = self.analyze_task_requirements(task_description)

        # Evaluate persona capabilities
        persona_scores = {}
        for persona in self.team_config['team_structure']:
            capability_match = self.evaluate_persona_capability(persona, task_analysis)
            context_relevance = self.assess_context_relevance(persona, context)
            workload_balance = self.check_workload_balance(persona)

            persona_scores[persona] = {
                'capability_score': capability_match,
                'context_relevance': context_relevance,
                'workload_balance': workload_balance,
                'overall_score': (capability_match * 0.5) + (context_relevance * 0.3) + (workload_balance * 0.2)
            }

        # Return top scoring persona
        best_persona = max(persona_scores.keys(), key=lambda x: persona_scores[x]['overall_score'])
        return best_persona, persona_scores[best_persona]
```

### Strategy 2: Progressive Quality Validation
```python
class ProgressiveQualityValidator:
    def validate_with_progression(self, deliverable, context):
        """Apply increasingly thorough validation based on deliverable type"""

        validation_levels = {
            'code_commit': ['syntax_check', 'unit_tests'],
            'feature_complete': ['syntax_check', 'unit_tests', 'integration_tests', 'security_scan'],
            'sprint_complete': ['syntax_check', 'unit_tests', 'integration_tests', 'security_scan', 'performance_test', 'accessibility_check'],
            'release_candidate': ['syntax_check', 'unit_tests', 'integration_tests', 'security_scan', 'performance_test', 'accessibility_check', 'load_test', 'compliance_check']
        }

        deliverable_type = self.classify_deliverable(deliverable)
        required_checks = validation_levels.get(deliverable_type, validation_levels['code_commit'])

        results = {}
        for check_name in required_checks:
            check_function = getattr(self, f"check_{check_name}")
            results[check_name] = check_function(deliverable, context)

        return self.summarize_validation_results(results)
```

### Strategy 3: Adaptive Workflow Optimization
```python
class AdaptiveWorkflowOptimizer:
    def optimize_workflow(self, historical_performance, current_context):
        """Adapt workflow based on performance data and context"""

        # Analyze historical performance
        performance_analysis = self.analyze_historical_performance(historical_performance)

        # Identify bottlenecks
        bottlenecks = self.identify_bottlenecks(performance_analysis)

        # Generate optimization recommendations
        optimizations = self.generate_optimizations(bottlenecks, current_context)

        # Apply safe optimizations
        applied_optimizations = []
        for optimization in optimizations:
            if self.validate_optimization_safety(optimization, current_context):
                self.apply_optimization(optimization)
                applied_optimizations.append(optimization)

        return applied_optimizations
```

## Integration with Existing Tools

### Git Integration
```bash
# Automated commit message generation
cat > git_integration.py << 'EOF'
#!/usr/bin/env python3
import subprocess
import json
import re

class GitIntegrationManager:
    def generate_commit_message(self, changes_description):
        """Generate conventional commit message from AI analysis"""

        # Analyze changes using AI
        analysis = self.analyze_changes(changes_description)

        # Generate structured commit message
        commit_type = self.determine_commit_type(analysis)
        scope = self.extract_scope(analysis)
        description = self.create_description(analysis)

        commit_message = f"{commit_type}"
        if scope:
            commit_message += f"({scope})"
        commit_message += f": {description}"

        # Add body if needed
        if analysis.get('breaking_changes'):
            commit_message += "\n\nBREAKING CHANGE: " + analysis['breaking_changes']

        return commit_message

    def create_feature_branch(self, feature_name):
        """Create descriptive feature branch"""
        branch_name = f"feature/{feature_name.lower().replace(' ', '-')}"
        subprocess.run(['git', 'checkout', '-b', branch_name], check=True)
        return branch_name

    def analyze_changes(self, description):
        """Use AI to analyze the nature of changes"""
        # This would integrate with your AI analysis system
        return {
            'type': 'feat',  # or 'fix', 'docs', 'style', 'refactor', 'test', 'chore'
            'scope': 'authentication',
            'description': 'add JWT token validation',
            'breaking_changes': None
        }
EOF
```

### Project Management Integration
```bash
# Trello/Jira integration example
cat > project_management_integration.py << 'EOF'
#!/usr/bin/env python3
import requests
import json
from datetime import datetime

class ProjectManagementIntegrator:
    def __init__(self, api_key, api_token, board_id):
        self.api_key = api_key
        self.api_token = api_token
        self.board_id = board_id
        self.base_url = "https://api.trello.com/1"

    def create_sprint_board(self, sprint_name):
        """Create Trello board for sprint"""

        # Create new board
        board_data = {
            'name': f"Sprint: {sprint_name}",
            'key': self.api_key,
            'token': self.api_token
        }

        response = requests.post(f"{self.base_url}/boards", params=board_data)
        board = response.json()

        # Create standard lists
        list_names = ['Backlog', 'To Do', 'In Progress', 'Review', 'Done']
        lists = {}
        for list_name in list_names:
            list_data = {
                'name': list_name,
                'idBoard': board['id'],
                'key': self.api_key,
                'token': self.api_token
            }
            list_response = requests.post(f"{self.base_url}/lists", params=list_data)
            lists[list_name] = list_response.json()

        return board, lists

    def create_user_story_card(self, user_story, list_id):
        """Create Trello card from user story"""

        card_data = {
            'name': user_story['title'],
            'desc': user_story['description'],
            'idList': list_id,
            'key': self.api_key,
            'token': self.api_token
        }

        # Add labels based on story type/priority
        if user_story.get('labels'):
            card_data['idLabels'] = user_story['labels']

        response = requests.post(f"{self.base_url}/cards", params=card_data)
        card = response.json()

        # Add checklist for acceptance criteria
        if user_story.get('acceptance_criteria'):
            checklist_data = {
                'name': 'Acceptance Criteria',
                'idCard': card['id'],
                'key': self.api_key,
                'token': self.api_token
            }
            checklist_response = requests.post(f"{self.base_url}/checklists", params=checklist_data)
            checklist = checklist_response.json()

            # Add checklist items
            for criterion in user_story['acceptance_criteria']:
                item_data = {
                    'name': criterion,
                    'idChecklist': checklist['id'],
                    'key': self.api_key,
                    'token': self.api_token
                }
                requests.post(f"{self.base_url}/checklists/{checklist['id']}/checkItems", params=item_data)

        return card

    def update_card_status(self, card_id, new_status, comment=None):
        """Update card status and add comment"""

        # Move card to new list
        list_data = {
            'idList': new_status,
            'key': self.api_key,
            'token': self.api_token
        }
        requests.put(f"{self.base_url}/cards/{card_id}", params=list_data)

        # Add comment if provided
        if comment:
            comment_data = {
                'text': comment,
                'key': self.api_key,
                'token': self.api_token
            }
            requests.post(f"{self.base_url}/cards/{card_id}/actions/comments", params=comment_data)

    def sync_sprint_progress(self, sprint_data):
        """Sync sprint progress from AI team to project management tool"""

        # This would integrate with your sprint execution system
        # to keep project management tools in sync with AI team progress

        sync_report = {
            'completed_stories': [],
            'in_progress_stories': [],
            'blocked_stories': [],
            'sync_timestamp': datetime.now().isoformat()
        }

        return sync_report
EOF
```

## Success Metrics & KPIs

### Team Performance KPIs
```yaml
kpis:
  productivity:
    - sprint_velocity: "Story points completed per sprint"
    - lead_time: "Time from requirement to deployment"
    - deployment_frequency: "How often deployments occur"
    - change_failure_rate: "Percentage of deployments causing issues"

  quality:
    - defect_density: "Bugs per thousand lines of code"
    - code_coverage: "Percentage of code covered by tests"
    - technical_debt_ratio: "Technical debt as percentage of total code"
    - security_vulnerabilities: "Number of security issues found"

  efficiency:
    - context_utilization: "Percentage of context effectively used"
    - ai_response_accuracy: "Percentage of accurate AI responses"
    - coordination_overhead: "Time spent on team coordination"
    - automation_coverage: "Percentage of manual tasks automated"

  stakeholder_satisfaction:
    - requirement_accuracy: "Percentage of requirements correctly interpreted"
    - delivery_predictability: "Ability to meet delivery commitments"
    - communication_quality: "Stakeholder satisfaction with updates"
    - business_value_delivery: "Business value delivered per sprint"
```

### Performance Benchmarking
```python
class PerformanceBenchmarker:
    def benchmark_ai_team(self, project_metrics):
        """Compare AI team performance against industry benchmarks"""

        benchmarks = {
            'productivity': {
                'excellent': {'sprint_velocity': 50, 'lead_time_days': 7},
                'good': {'sprint_velocity': 35, 'lead_time_days': 14},
                'average': {'sprint_velocity': 25, 'lead_time_days': 21}
            },
            'quality': {
                'excellent': {'defect_density': 0.5, 'code_coverage': 90},
                'good': {'defect_density': 1.0, 'code_coverage': 80},
                'average': {'defect_density': 2.0, 'code_coverage': 70}
            }
        }

        performance_rating = {}
        for category, metrics in benchmarks.items():
            category_score = 0
            for metric, thresholds in metrics.items():
                if metric in project_metrics:
                    actual_value = project_metrics[metric]
                    if category == 'productivity':
                        # Higher values are better for productivity
                        if actual_value >= thresholds['excellent']:
                            category_score += 3
                        elif actual_value >= thresholds['good']:
                            category_score += 2
                        else:
                            category_score += 1
                    else:
                        # Lower values are better for quality
                        excellent_threshold = thresholds['excellent']
                        good_threshold = thresholds['good']
                        if actual_value <= excellent_threshold:
                            category_score += 3
                        elif actual_value <= good_threshold:
                            category_score += 2
                        else:
                            category_score += 1

            # Convert to rating
            if category_score >= 8:
                performance_rating[category] = 'excellent'
            elif category_score >= 5:
                performance_rating[category] = 'good'
            else:
                performance_rating[category] = 'needs_improvement'

        return performance_rating
```

## Implementation Roadmap

### Phase 1: Foundation (Week 1-2)
- ‚úÖ Set up team configuration system
- ‚úÖ Implement basic context management
- ‚úÖ Create simple orchestration script
- ‚úÖ Establish quality gates

### Phase 2: Core Workflows (Week 3-4)
- ‚è≥ Implement sprint planning workflow
- ‚è≥ Build development pipeline
- ‚è≥ Create QA automation
- ‚è≥ Set up deployment processes

### Phase 3: Intelligence (Week 5-6)
- ‚è≥ Add context-aware task assignment
- ‚è≥ Implement adaptive workflows
- ‚è≥ Create performance monitoring
- ‚è≥ Build learning systems

### Phase 4: Optimization (Week 7-8)
- ‚è≥ Optimize context management
- ‚è≥ Enhance quality validation
- ‚è≥ Implement advanced analytics
- ‚è≥ Create predictive systems

### Phase 5: Scaling (Week 9-10)
- ‚è≥ Add multi-project support
- ‚è≥ Implement team scaling strategies
- ‚è≥ Create enterprise integrations
- ‚è≥ Build advanced reporting

## Success Criteria

### Functional Success
- **Solo Developer Productivity**: Achieve 5+ person equivalent output
- **Project Completion**: Successfully deliver 90%+ of committed features
- **Quality Standards**: Maintain enterprise-grade code quality
- **Delivery Speed**: Reduce development cycle time by 60%+

### Technical Success
- **AI Coordination**: Seamless collaboration between 8 AI personas
- **Context Management**: 12x longer context retention achieved
- **Quality Automation**: 95%+ automated quality validation
- **Performance**: Sub-second response times for common operations

### Business Success
- **Client Satisfaction**: Achieve 90%+ client satisfaction scores
- **Project Win Rate**: Successfully compete for enterprise projects
- **Cost Efficiency**: Reduce development costs by 70%+
- **Scalability**: Support projects requiring 15+ person teams

---

**AI Team Simulation Kit**
**Version**: 1.0.0
**Target**: Solo developers handling enterprise-scale projects
**Goal**: Simulate 5+ person development teams through AI orchestration
**Success Metric**: Achieve enterprise development standards with solo developer efficiency